---
layout: post

title: Python基础学习（三）

categories: Python

---

## 函数

### 函数的定义

还记得 Python 里面“万物皆对象”么？Python 把函数也当成对象，可以从另一个函数中返回出来而去构建高阶函数，比如：
参数是函数、返回值是函数。

我们首先来介绍函数的定义。

- 函数以`def`关键词开头，后接函数名和圆括号()。
- 函数执行的代码以冒号起始，并且缩进。
- return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回`None`。



> def functionname (parameters):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;"函数_文档字符串"<br>
> &nbsp; &nbsp; &nbsp; &nbsp; function_suite<br>
> &nbsp; &nbsp; &nbsp; &nbsp; return [expression]

### 函数的调用


```python
def printme(str):
    print(str)
    
printme("我要调用用户自定义函数！")
printme("再次调用同一函数")
temp = printme('hello')
print(temp)
```

    我要调用用户自定义函数！
    再次调用同一函数
    hello
    None



```python
def add(a,b):
    print(a+b)
    
add(1,2)
add([1,2,3],[4,5,6])
```

    3
    [1, 2, 3, 4, 5, 6]


### 函数文档


```python
def MyFirstFunction(name):
    "函数定义过程中name是形参"   # doc内容
    print('传递进来的{0}叫做实参，因为Ta是具体的参数值！'.format(name))

MyFirstFunction('老马的程序人生')
print(MyFirstFunction.__doc__)

help(MyFirstFunction)
```

    传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！
    函数定义过程中name是形参
    Help on function MyFirstFunction in module __main__:
    
    MyFirstFunction(name)
        函数定义过程中name是形参
    


### 函数参数

Python 的函数具有非常灵活多样的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。从简到繁的参数形态如下：
- 位置参数 (positional argument)
- 默认参数 (default argument)
- 可变参数 (variable argument)
- 关键字参数 (keyword argument)
- 命名关键字参数 (name keyword argument)
- 参数组合

**1. 位置参数**

> def functionname(arg1):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;"函数_文档字符串"<br>
> &nbsp; &nbsp; &nbsp; &nbsp;function_suite<br>
> &nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br>

- `arg1` - 位置参数 ，这些参数在调用函数 (call function) 时位置要固定。

**2. 默认参数**


> def functionname(arg1, arg2=v):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;"函数_文档字符串"<br>
> &nbsp; &nbsp; &nbsp; &nbsp;function_suite<br>
> &nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br>

- `arg2 = v` - 默认参数 = 默认值，调用函数时，默认参数的值如果没有传入，则被认为是默认值。
- 默认参数一定要放在位置参数 <b>后面</b>，不然程序会报错。


```python
def printinfo(name, age=8):  # name是位置参数，age是默认参数
    print('Name:{0},Age:{1}'.format(name,age))

printinfo('小马')
printinfo('小马',10)
# Python允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
printinfo(age=8,name='小马')
```

    Name:小马,Age:8
    Name:小马,Age:10
    Name:小马,Age:8


**3. 可变参数**

顾名思义，可变参数就是传入的参数个数是可变的，可以是 0, 1, 2 到任意个，是不定长的参数。


> def functionname(arg1, arg2=v, *args):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;"函数_文档字符串"<br>
> &nbsp; &nbsp; &nbsp; &nbsp;function_suite<br>
> &nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br>

- `*args` - 可变参数，可以是从零个到任意个，自动组装成元组。
- 加了星号（*）的变量名会存放所有未命名的变量参数。


```python
def printinfo(arg1, *args):   # 这样的话参数可以不定长
    print(arg1)
    for var in args:
        print(var)

printinfo(10)
printinfo(70,60,50)
```

    10
    70
    60
    50


**4. 关键字参数**


> def functionname(arg1, arg2=v, \*args, \**kw):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;"函数_文档字符串"<br>
> &nbsp; &nbsp; &nbsp; &nbsp;function_suite<br>
> &nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br>

- `**kw` - 关键字参数，可以是从零个到任意个，自动组装成字典。


```python
def printinfo(arg1,*args,**kwargs):    # args自动组装成元组，kwargs自动组装成字典
    print(arg1)
    print(args)
    print(kwargs)

printinfo(70,60,50,800)  
printinfo(70,60,50,a=1,b=2)
```

    70
    (60, 50, 800)
    {}
    70
    (60, 50)
    {'a': 1, 'b': 2}


**5. 命名关键字参数**

> def functionname(arg1, arg2=v, \*args, \*, nkw, \**kw):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;"函数_文档字符串"<br>
> &nbsp; &nbsp; &nbsp; &nbsp;function_suite<br>
> &nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br>

- `*, nkw` - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 `*`。
- 如果要限制关键字参数的名字，就可以用「命名关键字参数」
- 使用命名关键字参数时，要特别注意不能缺少参数名。


```python
def printinfo(arg1,*,nkw,**kwargs):
    print(arg1)
    print(nkw)
    print(kwargs)

printinfo(70,nkw=10,a=1,b=2)   # nkw是命名关键字
printinfo(70,10,a=1,b=2)
```

    70
    10
    {'a': 1, 'b': 2}



    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-10-236fbb56942a> in <module>
          5 
          6 printinfo(70,nkw=10,a=1,b=2)   # nkw是关键字
    ----> 7 printinfo(70,10,a=1,b=2)
    

    TypeError: printinfo() takes 1 positional argument but 2 were given


没有写参数名`nwk`，因此 10 被当成「位置参数」，而原函数只有 1 个位置函数，现在调用了 2 个，因此程序会报错。

**6. 参数组合**

在 Python 中定义函数，可以用位置参数、默认参数、可变参数、命名关键字参数和关键字参数，这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是：
- 位置参数、默认参数、可变参数和关键字参数。
- 位置参数、默认参数、命名关键字参数和关键字参数。

要注意定义可变参数和关键字参数的语法：
- `*args` 是可变参数，`args` 接收的是一个 `tuple`
- `**kw` 是关键字参数，`kw` 接收的是一个 `dict`

命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数不要忘了写分隔符 `*`，否则定义的是位置参数。

警告：虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数很难懂。

### 函数的返回值


```python
def add(a,b):
    return a+b

print(add(1,2))
print(add([1,2,3],[4,5,6]))
```

    3
    [1, 2, 3, 4, 5, 6]



```python
def back():
    return [1,'小马的程序人生',3.14]

print(back())
```

    [1, '小马的程序人生', 3.14]



```python
def back():     # 返回不止一个
    return 1,'小马的程序人生',3.14

print(back())
```

    (1, '小马的程序人生', 3.14)



```python
def printme(str):   # 没有返回就是None
    print(str)

temp = printme('hello')
print(temp)
print(type(temp))
```

    hello
    None
    <class 'NoneType'>


### 变量作用域

- Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。
- 定义在函数内部的变量拥有局部作用域，该变量称为局部变量。
- 定义在函数外部的变量拥有全局作用域，该变量称为全局变量。
- 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。


```python
def discounts(price,rate):
    final_price = price * rate
    return final_price

old_price = float(input('请输入原价：'))
rate = float(input('请输入折扣率：'))
new_price = discounts(old_price,rate)
print('打折后价格是：%.2f' % new_price)
```

    请输入原价：98
    请输入折扣率：0.9
    打折后价格是：88.20


- 当内部作用域想修改外部作用域的变量时，就要用到`global`和`nonlocal`关键字了。


```python
num = 1

# 内部作用域可以访问全局变量，但是不能修改，需要修改必须用到global或者nonlocal
def fun1():
    global num
    print(num)
    num = 123
    print(num)
    
fun1()
print(num)
```

    1
    1
    1


内嵌函数


```python
def outer():
    print('outer函数在这被调用')
    
    def inner():
        print('inner函数在这被调用')
    
    inner()  # 该函数只能在outer函数内部被调用
    
outer()
```

    outer函数在这被调用
    inner函数在这被调用


闭包

- 是函数式编程的一个重要的语法结构，是一种特殊的内嵌函数。
- 如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。
- 通过闭包可以访问外层非全局作用域的变量，这个作用域称为 <b>闭包作用域</b>。


```python
# 可以理解为一个复合函数
def funX(x):
    def funY(y):
        return x*y
    
    return funY   # 返回函数

i = funX(8)
print(type(i))
print(i(5))
```

    <class 'function'>
    40


闭包的返回值通常是函数


```python
def make_counter(init):
    counter = [init]
    
    def inc():
        counter[0]+=1
    def dec():
        counter[0]-=1
    def get():
        return counter[0]
    def reset():
        counter[0]=init
    
    return inc,dec,get,reset

inc,dec,get,reset = make_counter(0)
inc()
inc()
inc()
print(get())
dec()
print(get())
reset()
print(get())
```

    3
    2
    0


如果要修改闭包作用域中的变量则需要`nonlocal`关键字


```python
def outer():
    num = 10
    
    def inner():
        nonlocal num
        num = 100
        print(num)
        
    inner()
    print(num)

    
outer()
```

    100
    100


递归

- 如果一个函数在内部调用自身本身，这个函数就是递归函数。

【例子】`n! = 1 x 2 x 3 x ... x n`


```python
# 利用循环
n = 5
for k in range(1,5):
    n = n * k
print(n)

# 利用递归
def factorial(n):
    if n==1:
        return 1
    return n*factorial(n-1)
print(factorial(5))
```

    120
    120


【例子】斐波那契数列 `f(n)=f(n-1)+f(n-2), f(0)=0 f(1)=1`


```python
# 利用循环
i = 0
j = 1
lst = list([i,j])
for k in range(2,11):
    k = i + j
    lst.append(k)
    i = j
    j = k
print(lst)

# 利用递归
def recur_fibo(n):
    if n<=1:
        return n
    return recur_fibo(n-1)+recur_fibo(n-2)

lst = list()
for k in range(11):
    lst.append(recur_fibo(k))
print(lst)
```

    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


【例子】设置递归的层数，Python默认递归层数为 100


```python
import sys
sys.setrecursionlimit(1000)
```

## Lambda表达式

### 匿名函数的定义

在 Python 里有两类函数：
- 第一类：用 `def` 关键词定义的正规函数
- 第二类：用 `lambda` 关键词定义的匿名函数

Python 使用 `lambda` 关键词来创建匿名函数，而非`def`关键词，它没有函数名，其语法结构如下：

> lambda argument_list: expression

- `lambda` - 定义匿名函数的关键词。
- `argument_list` - 函数参数，它们可以是位置参数、默认参数、关键字参数，和正规函数里的参数类型一样。
- `:`- 冒号，在函数参数和表达式中间要加个冒号。
- `expression` - 只是一个表达式，输入函数参数，输出一些值。

注意：
- `expression` 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。
- 匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。


```python
def sqr(x):
    return x**2

print(sqr)

y = [sqr(x) for x in range(10)]
print(y)

lbd_sqr = lambda x:x**2
print(lbd_sqr)

y = [lbd_sqr(x) for x in range(10)]
print(y)

sumary = lambda arg1, arg2: arg1 + arg2
print(sumary(10,20))

func = lambda *args:sum(args)
print(func(1,2,3,4,5))
```

    <function sqr at 0x7fd3c0441ee0>
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    <function <lambda> at 0x7fd3c0441430>
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    30
    15


### 匿名函数的应用

函数式编程 是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。

【例子】非函数式编程


```python
def f(x):
    for i in range(0,len(x)):
        x[i] += 10
    return x

x = [1,2,3]
f(x)
print(x)   # x在函数运行时被改变了值，所以不是函数式编程
```

    [11, 12, 13]


【例子】函数式编程


```python
def f(x):
    y = []
    for item in x:
        y.append(item+10)
    return y

x = [1,2,3]
f(x)
print(x)
```

    [1, 2, 3]


匿名函数 常常应用于函数式编程的高阶函数 (high-order function)中，主要有两种形式：
- 参数是函数 (filter, map)
- 返回值是函数 (closure)


如，在 `filter`和`map`函数中的应用：

- `filter(function, iterable)` 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 `list()` 来转换。

【例子】


```python
odd = lambda x: x%2==1
templist = filter(odd,[1,2,3,4,5,6,7,8,9])
print(list(templist))
```

    [1, 3, 5, 7, 9]


- `map(function, *iterables)` 根据提供的函数对指定序列做映射。


```python
m1 = map(lambda x:x**2,[1,2,3,4,5])
print(list(m1))

m2 = map(lambda x,y:x+y,[1,3,4,7,9],[2,4,6,8,10])
print(list(m2))
```

    [1, 4, 9, 16, 25]
    [3, 7, 10, 15, 19]


除了 Python 这些内置函数，我们也可以自己定义高阶函数。


```python
def apply_to_list(fun,some_list):
    return fun(some_list)

lst = [1,2,3,4,5]
print(apply_to_list(sum,lst))

print(apply_to_list(len,lst))

print(apply_to_list(lambda x:sum(x)/len(x),lst))
```

    15
    5
    3.0


对于多个输入值的函数映射，可以通过追加迭代对象实现：


```python
list(map(lambda x,y:str(x)+'_'+y,range(5),list('abcde')))
```




    ['0_a', '1_b', '2_c', '3_d', '4_e']



## 类与对象

### 对象=属性+方法

对象是类的实例。换句话说，类主要定义对象的结构，然后我们以类为模板创建对象。类不但包含方法定义，而且还包含所有实例共享的数据。

- 封装：信息隐蔽技术

我们可以使用关键字 `class` 定义 Python 类，关键字后面紧跟类的名称、分号和类的实现。


```python
class Turtle:   # Python中的类名约定以大写字母开头
    """关于类的一个简单例子"""
    # 属性
    color = 'green'
    weight = 10
    legs = 4
    shell = True
    mouth = '大嘴'
    
    # 方法
    def climb(self):
        print('我正在很努力的向前爬...')
        
    def run(self):
        print('我正在飞快的向前跑...')
        
    def bite(self):
        print('咬死你咬死你！！')
        
    def eat(self):
        print('有的吃，真满足...')
        
    def sleep(self):
        print('困了，睡了，晚安，zzz')
        
# 注意缩进    
tt = Turtle()
print(tt)
print(type(tt))
print(tt.__class__)
print(tt.__class__.__name__)
    
tt.climb()
tt.run()
tt.bite()
    
print(type(Turtle))   # Python类也是对象，它们是type的实例
```

    <__main__.Turtle object at 0x7fd3c1083c10>
    <class '__main__.Turtle'>
    <class '__main__.Turtle'>
    Turtle
    我正在很努力的向前爬...
    我正在飞快的向前跑...
    咬死你咬死你！！
    <class 'type'>


- 继承：子类自动共享父类之间数据和方法的机制


```python
class MyList(list):
    pass

lst = MyList([1,5,2,7,8])
lst.append(9)
lst.sort()
print(lst)
```

    [1, 2, 5, 7, 8, 9]


- 多态：不同对象对同一方法响应不同的行动


```python
class Animal:
    def run(self):
        raise AttributeError('子类必须实现这个方法')
    
class People(Animal):
    def run(self):
        print('人正在走')
        
class Pig(Animal):
    def run(self):
        print('pig is walking')
        
class Dog(Animal):
    def run(self):
        print('dog is running')
        
def func(animal):
    animal.run()

func(Pig())
```

    pig is walking


### self是什么？

Python 的 `self` 相当于 C++ 的 `this` 指针。


```python
class Test:
    def prt(self):
        print(self)
        print(self.__class__)
        
t = Test()
t.prt()
```

    <__main__.Test object at 0x7fd3c1fc3d30>
    <class '__main__.Test'>


类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 `self`。在调用方法时，我们无需明确提供与参数 `self` 相对应的参数。


```python
class Ball:
    def setName(self,name):
        self.name = name
    
    def kick(self):
        print("我叫%s,该死的，谁替我..." % self.name)
        
a = Ball()
a.setName('球A')
b = Ball()
b.setName('球B')
a.kick()
b.kick()
```

    我叫球A,该死的，谁替我...
    我叫球B,该死的，谁替我...


### Python的魔法方法

据说，Python 的对象天生拥有一些神奇的方法，它们是面向对象的 Python 的一切...

它们是可以给你的类增加魔力的特殊方法...

如果你的对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的...

类有一个名为`__init__(self[, param1, param2...])`的魔法方法，该方法在类实例化时会自动调用。


```python
class Ball:
    def __init__(self,name):
        self.name=name
    
    def kick(self):
        print("我叫%s,该死的，谁踢我..."% self.name)

a = Ball("球A")
b = Ball("球B")
a.kick()
b.kick()
```

    我叫球A,该死的，谁踢我...
    我叫球B,该死的，谁踢我...


### 公有和私有

在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会为私有的了。


```python
class JustCounter:
    __secretCount = 0
    publicCount = 0
    
    def count(self):
        self.__secretCount+=1
        self.publicCount+=1
        print(self.__secretCount)
        
counter = JustCounter()
counter.count()
counter.count()
print(counter.publicCount)

print(counter._JustCounter__secretCounter)  # Python的私有为伪私有,只要这样就能访问私有变量
print(counter.__secretCount)
```

    1
    2
    2



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-45-b92f1796deb3> in <module>
         13 print(counter.publicCount)
         14 
    ---> 15 print(counter._JustCounter__secretCounter)  # Python的私有为伪私有,只要这样就能访问私有变量
         16 print(counter.__secretCount)


    AttributeError: 'JustCounter' object has no attribute '_JustCounter__secretCounter'


类的私有方法实例


```python
class Site:
    def __init__(self,name,url):
        self.name = name
        self.__url = url
    
    def who(self):
        print('name :',self.name)
        print('url :',self.__url)
        
    def __foo(self):
        print('这是私有方法')
        
    def foo(self):
        print('这是公共方法')
        self.__foo()
        
x = Site('老马的程序人生','https://blog.csdn.net/LSGO_MYP')
x.who()

x.foo()

x.__foo()
```

    name : 老马的程序人生
    url : https://blog.csdn.net/LSGO_MYP
    这是公共方法
    这是私有方法



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-46-2be7c38e6e89> in <module>
         20 x.foo()
         21 
    ---> 22 x.__foo()
    

    AttributeError: 'Site' object has no attribute '__foo'


### 继承

Python 同样支持类的继承，派生类的定义如下所示：


> class DerivedClassName(BaseClassName):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;statement-1<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;statement-N

`BaseClassName`（基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：

> class DerivedClassName(modname.BaseClassName):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;statement-1<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;statement-N


【例子】如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性。


```python
class people:
    name = ''
    age = 0
    __weight = 0
    
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    
    def speak(self):
        print("%s 说：我 %d 岁。"%(self.name,self.age))
        
# 单继承示例
class student(people):
    grade = ''
    
    def __init__(self,n,a,w,g):
        # 调用父类的构造函数
        people.__init__(self,n,a,w)
        self.grade = g
     
    # 覆写父类的方法
    def speak(self):
        print("%s 说：我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))
        
s = student('小马的程序人生',10,60,3)
s.speak()
```

    小马的程序人生 说：我 10 岁了，我在读 3 年级


注意：如果上面的程序去掉：`people.__init__(self, n, a, w)`，则输出：` 说: 我 0 岁了，我在读 3 年级`，因为子类的构造方法把父类的构造方法覆盖了。


```python
import random

class Fish:
    def __init__(self):
        self.x = random.randint(0,10)
        self.y = random.randint(0,10)
        
    def move(self):
        self.x -= 1
        print("我的位置",self.x,self.y)
        
class GoldFish(Fish):
    pass

class Carp(Fish):
    pass

class Salmon(Fish):
    pass

class Shark(Fish):
    def __init__(self):
        self.hungry = True
        
    def eat(self):
        if self.hungry:
            print("吃货的梦想就是天天有的吃！")
            self.hungry = False
        else:
            print("太撑了，吃不下了！")
            self.hungry = True

g = GoldFish()
g.move()
s = Shark()
s.eat()
s.move()
```

    我的位置 5 8
    吃货的梦想就是天天有的吃！



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-51-efc7695b37b2> in <module>
         35 s = Shark()
         36 s.eat()
    ---> 37 s.move()
    

    <ipython-input-51-efc7695b37b2> in move(self)
          7 
          8     def move(self):
    ----> 9         self.x -= 1
         10         print("我的位置",self.x,self.y)
         11 


    AttributeError: 'Shark' object has no attribute 'x'


解决该问题可用以下两种方式：
- 调用未绑定的父类方法`Fish.__init__(self)`


```python
class Shark(Fish):
    def __init__(self):
        Fish.__init__(self)
        self.hungry = True
    
    def eat(self):
        if self.hungry:
            print("吃货的梦想就是天天有的吃！")
            self.hungry = False
        else:
            print("太撑了，吃不下了！")
            self.hungry = True
```

- 使用super函数`super().__init__()`


```python
class Shark(Fish):
    def __init__(self):
        super().__init__()
        self.hungry = True
        
    def eat(self):
        if self.hungry:
            print("吃货的梦想就是天天有的吃！")
            self.hungry = False
        else:
            print("太撑了，吃不下了！")
            self.hungry = True
```

Python 虽然支持多继承的形式，但我们一般不使用多继承，因为容易引起混乱。


> class DerivedClassName(Base1, Base2, Base3):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;statement-1<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br>
> &nbsp; &nbsp; &nbsp; &nbsp;statement-N<br>


需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。


```python
class People:
    name = ''
    age = 0
    __weight = 0
    
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    
    def speak(self):
        print("%s 说：我 %d 岁。" % (self.name,self.age))
        
# 单继承示例
class Student(People):
    grade = ''
    
    def __init__(self,n,a,w,g):
        People.__init__(self,n,a,w)
        self.grade = g
        
    def speak(self):
        print("%s 说：我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))
    
# 另一个类，多重继承之前的准备
class Speaker:
    topic = ''
    name = ''
    
    def __init__(self,n,t):
        self.name = n
        self.topic = t
        
    def speak(self):
        print("我叫 %s,我是一个演说家，我演讲的主题是%s"%(self.name,self.topic))
        
# 多重继承
class Sample01(Speaker,Student):
    a = ''
    
    def __init__(self,n,a,w,g,t):
        Student.__init__(self,n,a,w,g)
        Speaker.__init__(self,n,t)
        
test = Sample01("Tim",25,80,4,"Python")
test.speak()

class Sample02(Student, Speaker):
    a = ''
    
    def __init__(self,n,a,w,g,t):
        Student.__init__(self,n,a,w,g)
        Speaker.__init__(self,n,t)
        
test = Sample02("Tim",25,80,4,"Python")
test.speak()
```

    我叫 Tim,我是一个演说家，我演讲的主题是Python
    Tim 说：我 25 岁了，我在读 4 年级


### 组合


```python
class Turtle:
    def __init__(self,x):
        self.num = x
        
class Fish:
    def __init__(self,x):
        self.num = x

class Pool:
    def __init__(self,x,y):
        self.turtle = Turtle(x)
        self.fish = Fish(y)
    
    def print_num(self):
        print("水池里面有乌龟%s只，小鱼%s条"%(self.turtle.num,self.fish.num))
        
p = Pool(2,3)
p.print_num()
```

    水池里面有乌龟2只，小鱼3条


### 类、类对象和实例对象

![类对象和实例对象](https://img-blog.csdnimg.cn/20191007090316462.png)

类对象：创建一个类，其实也是一个对象也在内存开辟了一块空间，称为类对象，类对象只有一个。

> class A(object):<br>
> &nbsp; &nbsp; &nbsp; &nbsp;pass

实例对象：就是通过实例化类创建的对象，称为实例对象，实例对象可以有多个。


```python
class A(object):
    pass

a = A()
b = A()
c = A()
```

类属性：类里面方法外面定义的变量称为类属性。类属性所属于类对象并且多个实例对象之间共享同一个类属性，说白了就是类属性所有的通过该类实例化的对象都能共享。


```python
class A():
    a = xx #类属性
    def __init__(self):
        A.a = XX   # 使用类属性可以通过（类名，类属性）调用
```

实例属性：实例属性和具体的某个实例对象有关系，并且一个实例对象和另外一个实例对象是不共享属性的，说白了实例属性只能在自己的对象里面使用，其他的对象不能直接使用，因为`self`是谁调用，它的值就属于该对象。


```python
# 创建类对象
class Test(object):
    class_attr = 100 # 类属性
    
    def __init__(self):
        self.sl_attr = 100 # 实例属性
        
    def func(self):
        print('类对象.类属性的值：', Test.class_attr)  # 调用类属性
        print('self.类属性的值',self.class_attr)     # 相当于把类属性编程实例属性
        print('self.实例属性的值',self.sl_attr)    # 调用实例属性
        
a = Test()
a.func()

b = Test()
b.func()

a.class_attr = 200   # self.类属性的值变为200
a.sl_attr = 200      # self.实例属性的值变为200
a.func()

Test.class_attr = 300    # 类对象.类属性的值变为300，类对象的类属性实例也共享，a的值为200因为a.class_attr覆盖了。
a.func()
b.func()
```

    类对象.类属性的值： 100
    self.类属性的值 100
    self.实例属性的值 100
    类对象.类属性的值： 100
    self.类属性的值 100
    self.实例属性的值 100
    类对象.类属性的值： 100
    self.类属性的值 200
    self.实例属性的值 200
    类对象.类属性的值： 300
    self.类属性的值 200
    self.实例属性的值 200
    类对象.类属性的值： 300
    self.类属性的值 300
    self.实例属性的值 100


类属性和实例属性区别：

1. 类属性：类外面，可以通过`实例对象.类属性`和`类名.类属性`进行调用。类里面，通过`self.类属性`和`类名.类属性`进行调用。
2. 实例属性：类外面，可以通过`实例对象.实例属性`调用。类里面，通过`self.实例属性`调用。
3. 实例属性就相当于局部变量。出了这个类或者这个类的实例对象，就没有作用了。
4. 类属性就相当于类里面的全局变量，可以和这个类的所有实例对象共享。

注意： 属性与方法名相同，属性会覆盖方法


```python
class A:
    def x(self):
        print('x_man')
        
aa = A()
aa.x()
aa.x = 1
print(aa.x)
aa.x()
```

    x_man
    1



    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-61-359b76ffda59> in <module>
          7 aa.x = 1
          8 print(aa.x)
    ----> 9 aa.x()
    

    TypeError: 'int' object is not callable


### 绑定

Python 严格要求方法需要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念。

Python 对象的数据属性通常存储在名为`.__ dict__`的字典中，我们可以直接访问`__dict__`，或利用 Python 的内置函数`vars()`获取`.__ dict__`。


```python
class CC:
    def setXY(self,x,y):
        self.x = x
        self.y = y
    
    def printXY(self):
        print(self.x,self.y)
        
dd = CC()
print(dd.__dict__)
print(vars(dd))
print(CC.__dict__)
dd.setXY(4,5)
print(dd.__dict__)
print(vars(CC))
print(CC.__dict__)
```

    {}
    {}
    {'__module__': '__main__', 'setXY': <function CC.setXY at 0x7fd3c1ee1ee0>, 'printXY': <function CC.printXY at 0x7fd3c1ee1430>, '__dict__': <attribute '__dict__' of 'CC' objects>, '__weakref__': <attribute '__weakref__' of 'CC' objects>, '__doc__': None}
    {'x': 4, 'y': 5}
    {'__module__': '__main__', 'setXY': <function CC.setXY at 0x7fd3c1ee1ee0>, 'printXY': <function CC.printXY at 0x7fd3c1ee1430>, '__dict__': <attribute '__dict__' of 'CC' objects>, '__weakref__': <attribute '__weakref__' of 'CC' objects>, '__doc__': None}
    {'__module__': '__main__', 'setXY': <function CC.setXY at 0x7fd3c1ee1ee0>, 'printXY': <function CC.printXY at 0x7fd3c1ee1430>, '__dict__': <attribute '__dict__' of 'CC' objects>, '__weakref__': <attribute '__weakref__' of 'CC' objects>, '__doc__': None}


### 一些相关的内置函数（BIF）

- `issubclass(class, classinfo)` 方法用于判断参数 class 是否是类型参数 classinfo 的子类。
- 一个类被认为是其自身的子类。
- `classinfo`可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回`True`。


```python
class A:
    pass

class B(A):
    pass

print(issubclass(B,A))
print(issubclass(B,B))
print(issubclass(A,B))
print(issubclass(B,object))
```

    True
    True
    False
    True


- `isinstance(object, classinfo)` 方法用于判断一个对象是否是一个已知的类型，类似`type()`。
- `type()`不会认为子类是一种父类类型，不考虑继承关系。
- `isinstance()`会认为子类是一种父类类型，考虑继承关系。
- 如果第一个参数不是对象，则永远返回`False`。
- 如果第二个参数不是类或者由类对象组成的元组，会抛出一个`TypeError`异常。


```python
a = 2
print(isinstance(a,int))
print(isinstance(a,str))
print(isinstance(a,(str,int,list)))

class A:
    pass

class B(A):
    pass

print(isinstance(A(),A))
print(type(A())==A)
print(isinstance(B(),A))
print(type(B())==A)
```

    True
    False
    True
    True
    True
    True
    False


- `hasattr(object, name)`用于判断对象是否包含对应的属性。


```python
class Coordinate:
    x = 10
    y = -5
    z = 0
    
point1 = Coordinate()
print(hasattr(point1,'x'))
print(hasattr(point1,'y'))
print(hasattr(point1,'z'))
print(hasattr(point1,'no'))
```

    True
    True
    True
    False


- `getattr(object, name[, default])`用于返回一个对象属性值。


```python
class A(object):
    bar  = 1
    
a = A()
print(getattr(a,'bar'))
print(getattr(a,'bar2',3))
print(getattr(a,'bar2'))
```

    1
    3



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-76-720aa8bc7859> in <module>
          5 print(getattr(a,'bar'))
          6 print(getattr(a,'bar2',3))
    ----> 7 print(getattr(a,'bar2'))
    

    AttributeError: 'A' object has no attribute 'bar2'


- `setattr(object, name, value)`对应函数 `getattr()`，用于设置属性值，该属性不一定是存在的。


```python
class A(object):
    bar=1

a = A()
print(getattr(a,'bar'))
setattr(a,'bar',5)
print(a.bar)
setattr(a,"age",28)
print(a.age)
```

    1
    5
    28


- `delattr(object, name)`用于删除属性。


```python
class Coordinate:
    x = 10
    y = -5
    z = 0
    
point1 = Coordinate()

print('x = ',point1.x)
print('y = ',point1.y)
print('z = ',point1.z)

delattr(Coordinate,'z')

print('--删除 z 属性后--')
print('x = ',point1.x)
print('y = ',point1.y)

# 触发错误
print('z = ',point1.z)
```

    x =  10
    y =  -5
    z =  0
    --删除 z 属性后--
    x =  10
    y =  -5



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-78-6422d435c63d> in <module>
         17 
         18 # 触发错误
    ---> 19 print('z = ',point1.z)
    

    AttributeError: 'Coordinate' object has no attribute 'z'


- `class property([fget[, fset[, fdel[, doc]]]])`用于在新式类中返回属性值。
    - `fget` -- 获取属性值的函数
    - `fset` -- 设置属性值的函数
    - `fdel` -- 删除属性值函数
    - `doc` -- 属性描述信息


```python
class C(object):
    def __init__(self):
        self.__x = None
        
    def getx(self):
        return self.__x
    
    def setx(self,value):
        self.__x = value
        
    def delx(self):
        del self.__x
    
    x = property(getx,setx,delx,"I'm the 'x' property.")  # 没看懂用法
    
cc = C()
cc.x = 2    # cc.x调用fget（即这里的getx）,cc.x = 2调用setx
print(cc.x)

del cc.x   # del cc.x调用delx
print(cc.x)
```

    2



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-3-14c7926704ca> in <module>
         19 
         20 del cc.x   # del cc.x调用delx
    ---> 21 print(cc.x)
    

    <ipython-input-3-14c7926704ca> in getx(self)
          4 
          5     def getx(self):
    ----> 6         return self.__x
          7 
          8     def setx(self,value):


    AttributeError: 'C' object has no attribute '_C__x'


## 魔法方法

魔法方法总是被双下划线包围，例如`__init__`。

魔法方法是面向对象的 Python 的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的 Python 的强大。

魔法方法的“魔力”体现在它们总能够在适当的时候被自动调用。

魔法方法的第一个参数应为`cls`（类方法） 或者`self`（实例方法）。
- `cls`：代表一个类的名称
- `self`：代表一个实例对象的名称

### 基本的魔法方法

- `__init__(self[, ...])` 构造器，当一个实例被创建的时候调用的初始化方法


```python
class Rectangle:
    def __init__(self,x,y):
        self.x = x
        self.y = y
        
    def getPeri(self):
        return (self.x+self.y)*2
    
    def getArea(self):
        return self.x*self.y
    
rect = Rectangle(4,5)
print(rect.getPeri())
print(rect.getArea())
```

    18
    20


- `__new__(cls[, ...])` 在一个对象实例化的时候所调用的第一个方法，在调用`__init__`初始化前，先调用`__new__`。
    - `__new__`至少要有一个参数`cls`，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给`__init__`。
    - `__new__`对当前类进行了实例化，并将实例返回，传给`__init__`的`self`。但是，执行了`__new__`，并不一定会进入`__init__`，只有`__new__`返回了，当前类`cls`的实例，当前类的`__init__`才会进入。


```python
class A(object):
    def __init__(self,value):
        print("into A __init__")
        self.value = value
        
    def __new__(cls,*args,**kwargs):
        print("into A __new__")
        print(cls)
        return object.__new__(cls)
    
class B(A):
    def __init__(self,value):
        print("into B __init__")
        self.value = value
        
    def __new__(cls,*args,**kwargs):
        print("into B __new__")
        print(cls)
        return super().__new__(cls,*args,**kwargs)
    
b = B(10)

class A(object):
    def __init__(self,value):
        print("into A __init__")
        self.value = value
    
    def __new__(cls,*args,**kwargs):
        print("into A __new__")
        print(cls)
        return object.__new__(cls)
    
class B(A):
    def __init__(self,value):
        print("into B __init__")
        self.value = value
        
    def __new__(cls,*args,**kwargs):
        print("into B __new__")
        print(cls)
        return super().__new__(A,*args,**kwargs)   # 改动了cls变为A,这种情况下执行了new不会执行init

b = B(10)
```

    into B __new__
    <class '__main__.B'>
    into A __new__
    <class '__main__.B'>
    into B __init__
    into B __new__
    <class '__main__.B'>
    into A __new__
    <class '__main__.A'>


- 若`__new__`没有正确返回当前类`cls`的实例，那`__init__`是不会被调用的，即使是父类的实例也不行，将没有`__init__`被调用。

【例子】利用`__new__`实现单例模式。


```python
class Earth:
    pass

a = Earth()
print(id(a))
b = Earth()
print(id(b))

class Earth:
    __instance = None    # 定义一个类属性做判断
    
    def __new__(cls):    # 创建一个单实例
        if cls.__instance is None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance
        
a = Earth()
print(id(a))
b = Earth()
print(id(b))
```

    140371202434000
    140371202434768
    140371202433232
    140371202433232


- `__new__`方法主要是当你继承一些不可变的 class 时（比如`int, str, tuple`）， 提供给你一个自定义这些类的实例化过程的途径。


```python
class CapStr(str):
    def __new__(cls,string):
        string = string.upper()
        return string.__new__(cls,string)

a = CapStr("i love lsgogroup")
print(a)
```

    I LOVE LSGOGROUP


- `__del__(self)` 析构器，当一个对象将要被系统回收之时调用的方法。

> Python 采用自动引用计数（ARC）方式来回收对象所占用的空间，当程序中有一个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 1；当程序中有两个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 2，依此类推，如果一个对象的引用计数变成了 0，则说明程序中不再有变量引用该对象，表明程序不再需要该对象，因此 Python 就会回收该对象。
>
> 大部分时候，Python 的 ARC 都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况，比如对象 a 持有一个实例变量引用对象 b，而对象 b 又持有一个实例变量引用对象 a，此时两个对象的引用计数都是 1，而实际上程序已经不再有变量引用它们，系统应该回收它们，此时 Python 的垃圾回收器就可能没那么快，要等专门的循环垃圾回收器（Cyclic Garbage Collector）来检测并回收这种引用循环。


```python
class C(object):
    def __init__(self):
        print('into C __init__')
        
    def __del__(self):
        print('into C __del__')
        
c1 = C()
c2 = c1
c3 = c2
del c3
del c2
del c1
```

    into C __init__
    into C __del__


- `__str__(self)`:
    - 当你打印一个对象的时候，触发`__str__`
    - 当你使用`%s`格式化的时候，触发`__str__`
    - `str`强转数据类型的时候，触发`__str__`

- `__repr__(self)`：
    - `repr`是`str`的备胎
    - 有`__str__`的时候执行`__str__`,没有实现`__str__`的时候，执行`__repr__`
    - `repr(obj)`内置函数对应的结果是`__repr__`的返回值
    - 当你使用`%r`格式化的时候 触发`__repr__


```python
class Cat:
    """定义一个猫类"""
    
    def __init__(self,new_name,new_age):
        """在创建完对象之后 会自动调用，它完成对象的初始化的功能"""
        self.name = new_name
        self.age = new_age
        
    def __str__(self):
        """返回一个对象的描述信息"""
        return "名字是：%s ,年龄是：%d"%(self.name,self.age)
    
    def __repr__(self):
        """返回一个对象的描述信息"""
        return "Cat:(%s,%d)"%(self.name,self.age)
    
    def eat(self):
        print("%s在吃鱼...."%self.name)
        
    def drink(self):
        print("%s在喝可乐..."%self.name)
        
    def introduce(self):
        print("名字是：%s,年龄是：%d"%(self.name,self.age))
        
tom = Cat("汤姆",30)
print(tom)
print(str(tom))
print(repr(tom))
tom.eat()
tom.introduce()
```

    名字是：汤姆 ,年龄是：30
    名字是：汤姆 ,年龄是：30
    Cat:(汤姆,30)
    汤姆在吃鱼....
    名字是：汤姆,年龄是：30


`__str__(self)` 的返回结果可读性强。也就是说，`__str__` 的意义是得到便于人们阅读的信息，就像下面的 '2019-10-11' 一样。

`__repr__(self)` 的返回结果应更准确。怎么说，`__repr__` 存在的目的在于调试，便于开发者使用。


```python
import datetime

today = datetime.date.today()
print(str(today))
print(repr(today))
print('%s'%today)
print('%r'%today)
```

    2021-04-26
    datetime.date(2021, 4, 26)
    2021-04-26
    datetime.date(2021, 4, 26)


### 算术运算符

类型工厂函数，指的是“不通过类而是通过函数来创建对象”。


```python
class C:
    pass

print(type(len))
print(type(dir))
print(type(int))
print(type(list))
print(type(tuple))
print(type(C))
print(int('123'))

# 这个例子中list工厂函数把一个元组对象加工成了一个列表对象
print(list((1,2,3)))
```

    <class 'builtin_function_or_method'>
    <class 'builtin_function_or_method'>
    <class 'type'>
    <class 'type'>
    <class 'type'>
    <class 'type'>
    123
    [1, 2, 3]


- `__add__(self, other)`定义加法的行为：`+`
- `__sub__(self, other)`定义减法的行为：`-`


```python
class MyClass:
    
    def __init__(self, height, weight):
        self.height = height
        self.weight = weight
        
    # 两个对象的长相加，宽不变，返回一个新的类
    def __add__(self,others):
        return MyClass(self.height+others.height,self.weight+others.weight)
    
    # 两个对象的宽相减，长不变，返回一个新的类
    def __sub__(self,others):
        return MyClass(self.height-others.height,self.weight-others.weight)
    
    # 说一下自己的参数
    def intro(self):
        print("高为",self.height,"重为",self.weight)
        
def main():
    a = MyClass(height=10,weight=5)
    a.intro()
    
    b = MyClass(height=20,weight=10)
    b.intro()
    
    c = b - a
    c.intro()
    
    d = a + b
    d.intro()
    
if __name__ == '__main__':
    main()
```

    高为 10 重为 5
    高为 20 重为 10
    高为 10 重为 5
    高为 30 重为 15


- `__mul__(self, other)`定义乘法的行为：`*`
- `__truediv__(self, other)`定义真除法的行为：`/`
- `__floordiv__(self, other)`定义整数除法的行为：`//`
- `__mod__(self, other)` 定义取模算法的行为：`%`
- `__divmod__(self, other)`定义当被 `divmod()` 调用时的行为
- `divmod(a, b)`把除数和余数运算结果结合起来，返回一个包含商和余数的元组`(a // b, a % b)`。


```python
print(divmod(7,2))
print(divmod(8,2))
```

    (3, 1)
    (4, 0)


- `__pow__(self, other[, module])`定义当被 `power()` 调用或 `**` 运算时的行为
- `__lshift__(self, other)`定义按位左移位的行为：`<<`
- `__rshift__(self, other)`定义按位右移位的行为：`>>`
- `__and__(self, other)`定义按位与操作的行为：`&`
- `__xor__(self, other)`定义按位异或操作的行为：`^`
- `__or__(self, other)`定义按位或操作的行为：`|`

### 反算术运算符

反运算魔方方法，与算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”。当文件左操作不支持相应的操作时被调用。

- `__radd__(self, other)`定义加法的行为：`+`
- `__rsub__(self, other)`定义减法的行为：`-`
- `__rmul__(self, other)`定义乘法的行为：`*`
- `__rtruediv__(self, other)`定义真除法的行为：`/`
- `__rfloordiv__(self, other)`定义整数除法的行为：`//`
- `__rmod__(self, other)` 定义取模算法的行为：`%`
- `__rdivmod__(self, other)`定义当被 divmod() 调用时的行为
- `__rpow__(self, other[, module])`定义当被 power() 调用或 `**` 运算时的行为
- `__rlshift__(self, other)`定义按位左移位的行为：`<<`
- `__rrshift__(self, other)`定义按位右移位的行为：`>>`
- `__rand__(self, other)`定义按位与操作的行为：`&`
- `__rxor__(self, other)`定义按位异或操作的行为：`^`
- `__ror__(self, other)`定义按位或操作的行为：`|`

`a + b`

这里加数是`a`，被加数是`b`，因此是`a`主动，反运算就是如果`a`对象的`__add__()`方法没有实现或者不支持相应的操作，那么 Python 就会调用`b`的`__radd__()`方法。


```python
class Nint(int):
    def __radd__(self,other):
        return int.__sub__(other,self)   # 注意self在后面
    
a = Nint(5)
b = Nint(3)
print(a+b)
print(1+b)
```

    8
    -2


### 增量赋值运算符

- `__iadd__(self, other)`定义赋值加法的行为：`+=`
- `__isub__(self, other)`定义赋值减法的行为：`-=`
- `__imul__(self, other)`定义赋值乘法的行为：`*=`
- `__itruediv__(self, other)`定义赋值真除法的行为：`/=`
- `__ifloordiv__(self, other)`定义赋值整数除法的行为：`//=`
- `__imod__(self, other)`定义赋值取模算法的行为：`%=`
- `__ipow__(self, other[, modulo])`定义赋值幂运算的行为：`**=`
- `__ilshift__(self, other)`定义赋值按位左移位的行为：`<<=`
- `__irshift__(self, other)`定义赋值按位右移位的行为：`>>=`
- `__iand__(self, other)`定义赋值按位与操作的行为：`&=`
- `__ixor__(self, other)`定义赋值按位异或操作的行为：`^=`
- `__ior__(self, other)`定义赋值按位或操作的行为：`|=`

### 一元运算符

- `__neg__(self)`定义负号的行为：`-x`
- `__pos__(self)`定义正号的行为：`+x`<br>
此处由王啸剑贡献订正
- `__abs__(self)`定义当被`abs()`调用时的行为
- `__invert__(self)`定义按位求反的行为：`~x`

### 属性访问

- `__getattr__(self, name)`: 定义当用户试图获取一个不存在的属性时的行为。
- `__getattribute__(self, name)`：定义当该类的属性被访问时的行为（先调用该方法，查看是否存在该属性，若不存在，接着去调用`__getattr__`）。
- `__setattr__(self, name, value)`：定义当一个属性被设置时的行为。
- `__delattr__(self, name)`：定义当一个属性被删除时的行为。


```python
class C:
    def __getattribute__(self,item):
        print('__getattribute__')
        return super().__getattribute__(item)
    
    def __getattr__(self,item):
        print('__getattr__')
        
    def __setattr__(self,key,value):
        print('__setattr__')
        super().__setattr__(key,value)
        
    def __delattr__(self,item):
        print('__delattr__')
        super().__delattr__(item)
        
c = C()
c.x
c.x = 1
del c.x
```

    __getattribute__
    __getattr__
    __setattr__
    __delattr__


### 描述符

描述符就是将某种特殊类型的类的实例指派给另一个类的属性。
- `__get__(self, instance, owner)`用于访问属性，它返回属性的值。
- `__set__(self, instance, value)`将在属性分配操作中调用，不返回任何内容。
- `__del__(self, instance)`控制删除操作，不返回任何内容。


```python
class MyDecriptor:
    def __get__(self,instance,owner):
        print('__get__',self,instance,owner)
    
    def __set__(self,instance,value):
        print('__set__',self,instance,value)
        
    def __delete__(self,instance):
        print('__delete__',self,instance)
        
class Test:
    x = MyDecriptor()
    
t = Test()
t.x             # 调用__get__
t.x = 'x-man'   # 调用__set__
del t.x         # 调用__delete__
```

    __get__ <__main__.MyDecriptor object at 0x7faab67a1c40> <__main__.Test object at 0x7faab83f43d0> <class '__main__.Test'>
    __set__ <__main__.MyDecriptor object at 0x7faab67a1c40> <__main__.Test object at 0x7faab83f43d0> x-man
    __delete__ <__main__.MyDecriptor object at 0x7faab67a1c40> <__main__.Test object at 0x7faab83f43d0>


### 定制序列

协议（Protocols）与其它编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在 Python 中的协议就显得不那么正式。事实上，在 Python 中，协议更像是一种指南。

**容器类型的协议**

- 如果说你希望定制的容器是不可变的话，你只需要定义`__len__()`和`__getitem__()`方法。
- 如果你希望定制的容器是可变的话，除了`__len__()`和`__getitem__()`方法，你还需要定义`__setitem__()`和`__delitem__()`两个方法。


【例子】编写一个不可改变的自定义列表，要求记录列表中每个元素被访问的次数。


```python
class CountList:
    def __init__(self,*args):
        self.values = [x for x in args]
        self.count = {}.fromkeys(range(len(self.values)),0)
        
    def __len__(self):
        return len(self.values)
    
    def __getitem__(self,item):
        self.count[item]+=1
        return self.values[item]
    
c1 = CountList(1,3,5,7,9)
c2 = CountList(2,4,6,8,10)
print(c1[1])
print(c2[2])
print(c1[1]+c2[1])
print(c1.count)
print(c2.count)
```

    3
    6
    7
    {0: 0, 1: 2, 2: 0, 3: 0, 4: 0}
    {0: 0, 1: 1, 2: 1, 3: 0, 4: 0}


- `__len__(self)`定义当被`len()`调用时的行为（返回容器中元素的个数）。
- `__getitem__(self, key)`定义获取容器中元素的行为，相当于`self[key]`。
- `__setitem__(self, key, value)`定义设置容器中指定元素的行为，相当于`self[key] = value`。
- `__delitem__(self, key)`定义删除容器中指定元素的行为，相当于`del self[key]`。


【例子】编写一个可改变的自定义列表，要求记录列表中每个元素被访问的次数。


```python
class CountList:
    def __init__(self,*args):
        self.values = [x for x in args]
        self.count = {}.fromkeys(range(len(self.values)),0)
        
    def __len__(self):
        return len(self.values)
    
    def __getitem__(self,item):
        self.count[item]+=1
        return self.values[item]
    
    def __setitem__(self,key,value):
        self.values[key]=value
        
    def __delitem__(self,key):
        del self.values[key]
        for i in range(0,len(self.values)):
            if i>=key:
                self.count[i]=self.count[i+1]
                
        self.count.pop(len(self.values))
        
c1 = CountList(1,3,5,7,9)
c2 = CountList(2,4,6,8,10)
print(c1[1])
print(c2[2])
c2[2] = 12
print(c1[1]+c2[2])
print(c1.count)
print(c2.count)
del c1[1]
print(c1.count)
```

    3
    6
    15
    {0: 0, 1: 2, 2: 0, 3: 0, 4: 0}
    {0: 0, 1: 0, 2: 2, 3: 0, 4: 0}
    {0: 0, 1: 0, 2: 0, 3: 0}


### 迭代器

- 迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。
- 迭代器是一个可以记住遍历的位置的对象。
- 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。
- 迭代器只能往前不会后退。
- 字符串，列表或元组对象都可用于创建迭代器：


```python
string = 'lsgogroup'
for c in string:
    print(c)
    
for c in iter(string):
    print(c)
```

    l
    s
    g
    o
    g
    r
    o
    u
    p
    l
    s
    g
    o
    g
    r
    o
    u
    p


- 迭代器有两个基本的方法：`iter()` 和 `next()`。
- `iter(object)` 函数用来生成迭代器。
- `next(iterator[, default])` 返回迭代器的下一个项目。
- `iterator` -- 可迭代对象
- `default` -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 `StopIteration` 异常。


```python
links = {'B':'百度','A':'阿里','T':'腾讯'}
it = iter(links)
print(next(it))
print(next(it))
print(next(it))
print(next(it))
```

    B
    A
    T



    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    <ipython-input-23-ed4a0b02eefb> in <module>
          4 print(next(it))
          5 print(next(it))
    ----> 6 print(next(it))
    

    StopIteration: 



```python
it = iter(links)
while True:
    try:
        each = next(it)
    except StopIteration:
        break
    print(each)
```

    B
    A
    T


把一个类作为一个迭代器使用需要在类中实现两个魔法方法 `__iter__()` 与 `__next__()` 。

- `__iter__(self)`定义当迭代容器中的元素的行为，返回一个特殊的迭代器对象， 这个迭代器对象实现了 `__next__()` 方法并通过 `StopIteration` 异常标识迭代的完成。
- `__next__()` 返回下一个迭代器对象。
- `StopIteration` 异常用于标识迭代的完成，防止出现无限循环的情况，在 `__next__()` 方法中我们可以设置在完成指定循环次数后触发 `StopIteration` 异常来结束迭代。


```python
class Fibs:
    def __init__(self,n=10):
        self.a = 0
        self.b = 1
        self.n = n
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.a,self.b = self.b,self.a+self.b
        if self.a>self.n:
            raise StopIteration
        return self.a
    
fibs = Fibs(100)
for each in fibs:
    print(each,end=' ')
```

    1 1 2 3 5 8 13 21 34 55 89 

### 生成器

- 在 Python 中，使用了 `yield` 的函数被称为生成器（generator）。
- 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
- 在调用生成器运行的过程中，每次遇到 `yield` 时函数会暂停并保存当前所有的运行信息，返回 `yield` 的值, 并在下一次执行 `next()` 方法时从当前位置继续运行。
- 调用一个生成器函数，返回的是一个迭代器对象。


```python
def myGen():
    print('生成器执行！')
    yield 1
    yield 2
    
myG = myGen()
print(next(myG))
print(next(myG))

myG = myGen()
for each in myG:
    print(each)
```

    生成器执行！
    1
    2
    生成器执行！
    1
    2


【例子】用生成器实现斐波那契数列。


```python
def libs(n):
    a = 0
    b = 1
    while True:
        a,b=b,a+b
        if a>n:
            return
        yield a
        
for each in libs(100):
    print(each,end=' ')
```

    1 1 2 3 5 8 13 21 34 55 89 
